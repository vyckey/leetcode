# [101. å¯¹ç§°äºŒå‰æ ‘](https://leetcode.cn/problems/symmetric-tree)

## é¢˜ç›®æè¿°

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œ æ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°ã€‚

ç¤ºä¾‹ 1ï¼š

![](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

> è¾“å…¥ï¼š`root = [1,2,2,3,4,4,3]`
> è¾“å‡ºï¼š`true`

ç¤ºä¾‹ 2ï¼š

![](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

> è¾“å…¥ï¼š`root = [1,2,2,null,3,null,3]`
> è¾“å‡ºï¼š`false`

æç¤ºï¼š

* æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[1, 1000]` å†…
* -$100$ <= `Node.val` <= $100$

è¿›é˜¶ï¼šä½ å¯ä»¥è¿ç”¨é€’å½’å’Œè¿­ä»£ä¸¤ç§æ–¹æ³•è§£å†³è¿™ä¸ªé—®é¢˜å—ï¼Ÿ

## å…¬å¸

- é˜¿é‡Œ
- è…¾è®¯
- ç™¾åº¦
- å­—èŠ‚
- bloomberg
- linkedin
- microsoft

## å‰ç½®çŸ¥è¯†

- [äºŒå‰æ ‘](https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md)
- [é€’å½’](https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md)

## æ€è·¯

çœ‹åˆ°è¿™é¢˜çš„æ—¶å€™ï¼Œæˆ‘çš„ç¬¬ä¸€ç›´è§‰æ˜¯ DFSã€‚ç„¶åæˆ‘å°±æƒ³:`å¦‚æœå·¦å­æ ‘æ˜¯é•œåƒï¼Œå¹¶ä¸”å³å­æ ‘ä¹Ÿæ˜¯é•œåƒï¼Œæ˜¯ä¸æ˜¯å°±è¯´æ˜æ•´ä½“æ˜¯é•œåƒï¼Ÿ`ã€‚ç»è¿‡å‡ ç§’çš„æ€è€ƒï¼Œ è¿™æ˜¾ç„¶æ˜¯ä¸å¯¹çš„ï¼Œä¸ç¬¦åˆé¢˜æ„ã€‚

![](https://p.ipic.vip/bke0ic.jpg)

å¾ˆæ˜æ˜¾å…¶ä¸­å·¦å­æ ‘ä¸­çš„èŠ‚ç‚¹ä¼šå’Œå³å­æ ‘ä¸­çš„èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒï¼Œæˆ‘æŠŠæ¯”è¾ƒçš„å…ƒç´ è¿›è¡Œäº†é¢œè‰²åŒºåˆ†ï¼Œæ–¹ä¾¿å¤§å®¶çœ‹ã€‚

è¿™é‡Œæˆ‘çš„æƒ³æ³•æ˜¯ï¼š`éå†æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™ï¼Œå¦‚æœæˆ‘éƒ½å¯ä»¥é€šè¿‡æŸç§æ–¹æ³•çŸ¥é“å®ƒå¯¹åº”çš„å¯¹ç§°èŠ‚ç‚¹æ˜¯è°ï¼Œè¿™æ ·çš„è¯æˆ‘ç›´æ¥æ¯”è¾ƒä¸¤è€…æ˜¯å¦ä¸€è‡´å°±è¡Œäº†ã€‚`

å› æ­¤æƒ³æ³•æ˜¯ä¸¤æ¬¡éå†ï¼Œç¬¬ä¸€æ¬¡éå†çš„åŒæ—¶å°†éå†ç»“æœå­˜å‚¨åˆ°å“ˆå¸Œè¡¨ä¸­ï¼Œç„¶åç¬¬äºŒæ¬¡éå†å»å“ˆå¸Œè¡¨å–ã€‚è¿™ç§æ–¹æ³•å¯è¡Œï¼Œä½†æ˜¯éœ€è¦ N çš„ç©ºé—´ï¼ˆN ä¸ºèŠ‚ç‚¹æ€»æ•°ï¼‰ã€‚æˆ‘æƒ³åˆ°å¦‚æœä¸¤è€…å¯ä»¥åŒæ—¶è¿›è¡Œéå†ï¼Œæ˜¯ä¸æ˜¯å°±çœå»äº†å“ˆå¸Œè¡¨çš„å¼€é”€ã€‚

![](https://p.ipic.vip/b9e8xo.jpg)

å¦‚æœä¸æ˜ç™½çš„è¯ï¼Œæˆ‘ä¸¾ä¸ªç®€å•ä¾‹å­ï¼š

```
ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯é•œåƒå¯¹ç§°çš„ã€‚ä¾‹å¦‚ï¼Œæ•°ç»„ [1,2,2,3,2,2,1] æ˜¯å¯¹ç§°çš„ã€‚
```

å¦‚æœç”¨å“ˆå¸Œè¡¨çš„è¯å¤§æ¦‚æ˜¯ï¼š

```py
seen = dict()
for i, num in enumerate(nums):
    seen[i] = num
for i, num in enumerate(nums):
    if  seen[len(nums) - 1 - i] != num:
      return False
return True
```

è€ŒåŒæ—¶éå†çš„è¯å¤§æ¦‚æ˜¯è¿™æ ·çš„ï¼š

```py
l = 0
r = len(nums) - 1

while l < r:
   if nums[l] != nums[r]: return False
   l += 1
   r -= 1
return True

```

> å…¶å®æ›´åƒæœ¬é¢˜ä¸€ç‚¹çš„è¯åº”è¯¥æ˜¯ä»ä¸­é—´åˆ†åˆ«å‘ä¸¤è¾¹æ‰©å±• ğŸ˜‚

## ä»£ç 

ä»£ç æ”¯æŒï¼šC++, Java, Python3

C++ Code:

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return root==NULL?true:recur(root->left, root->right);
    }

    bool recur(TreeNode* l, TreeNode* r)
    {
        if(l == NULL && r==NULL)
        {
            return true;
        }
        // åªå­˜åœ¨ä¸€ä¸ªå­èŠ‚ç‚¹ æˆ–è€…å·¦å³ä¸ç›¸ç­‰
        if(l==NULL || r==NULL || l->val != r->val)
        {
            return false;
        }

        return recur(l->left, r->right) && recur(l->right, r->left);
    }
};
```

Java Code:

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null)
        {
            return true;
        }
        else{
            return recur(root.left, root.right);
        }
        // return root == null ? true : recur(root.left, root.right);
    }

    public boolean recur(TreeNode l, TreeNode r)
    {
        if(l == null && r==null)
        {
            return true;
        }
        // åªå­˜åœ¨ä¸€ä¸ªå­èŠ‚ç‚¹ æˆ–è€…å·¦å³ä¸ç›¸ç­‰
        if(l==null || r==null || l.val != r.val)
        {
            return false;
        }

        return recur(l.left, r.right) && recur(l.right, r.left);
    }
}
```

Python3 Code:

```py

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        def dfs(root1, root2):
            if root1 == root2 == None: return True
            if not root1 or not root2: return False
            if root1.val != root2.val: return False
            return dfs(root1.left, root2.right) and dfs(root1.right, root2.left)
        if not root: return True
        return dfs(root.left, root.right)
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ N ä¸ºèŠ‚ç‚¹æ•°ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šé€’å½’çš„æ·±åº¦æœ€é«˜ä¸ºèŠ‚ç‚¹æ•°ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦æ˜¯ $O(N)$ï¼Œå…¶ä¸­ N ä¸ºèŠ‚ç‚¹æ•°ã€‚
